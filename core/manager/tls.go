package manager

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/tls"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/pem"
	"fmt"
	"io/ioutil"
	"math/big"
	"os"
	"time"

	"github.com/cloudwego/kitex/pkg/klog"
	"github.com/cloudwego/kitex/pkg/remote/trans/nphttp2/metadata"
)

var (
	// for test only
	rootCert = "-----BEGIN CERTIFICATE-----\nMIIC/DCCAeSgAwIBAgIQftGW216vlgDg+4eUqNq6yDANBgkqhkiG9w0BAQsFADAY\nMRYwFAYDVQQKEw1jbHVzdGVyLmxvY2FsMB4XDTIyMDcxNDE1MzAwMFoXDTMyMDcx\nMTE1MzAwMFowGDEWMBQGA1UEChMNY2x1c3Rlci5sb2NhbDCCASIwDQYJKoZIhvcN\nAQEBBQADggEPADCCAQoCggEBAN6tjtSHjNUpWcdb3D8hrjzPdKo9OzpMVNcDCc+1\neChkyS0c10R/Y/9Yj42FoB+zvfED0rss/M35Vfr4Vh8VJzY84MzMeXncc91HY7I6\n0IEgivZmQ3K2AD4X/OJY3n5Ik32b8f+inxq7SdgqBgPTE3Ni0hHxr3x/XlDqELyy\nkmQWvyKBkSjbgQlx6KasJBdgtBiqyud4PXI8iIQnSx/QqIX+ZFQe6rFnykVXaQr9\nUDtCcdbSNmQzndiazVKwveMLL5q308OhIotJs7BAPzZipk8ZC71sBrXz89RJkFBG\nucj+XAFWExAI2uveV33O7TfKUUJh2NOM5XoFoNpMvawHIzECAwEAAaNCMEAwDgYD\nVR0PAQH/BAQDAgIEMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFOvue8xVKw2Q\n35PxFr7vP/+9Q31wMA0GCSqGSIb3DQEBCwUAA4IBAQAGFUCl1TM75rnvJ2EuQ0gx\no4wa2ZsKAlGv/ApJ7HqBgFtbixnUbhavOHzPfpWJCtGZOSEzdXkvbSO74upyO9ju\nrHwZgSvViWubYkCx5AL+W1uH9zsyvrG/+uwSnU2t94Ui5+5tBipKf3JR99e+mgfD\n2mhEzKwKccq+vJbxivA2ycW8kPfqXf1xftBVVODDRfmwIUAoFU8GctR4k3YX+/rx\ndYXas3N6I75Hb6kIENcceXc2IUML1P86MVCdtRRa7744eZj0u7ZMn06lNBsuox8T\nl2+H3Az6RT3YzHYIzYC+2iAQ7feE+mBV7iLet1iVoCDdJUgZOqqirDiBsyF+ORp3\n-----END CERTIFICATE-----"

	keyPath  = "key.pem"
	certPath = "cert.pem"
	inited   bool

	// write key
	keyLogFileName      = "ssl-key.log"
	certificateTemplate = &x509.Certificate{
		IsCA:                  true,
		BasicConstraintsValid: true,
		SerialNumber:          big.NewInt(0),
		Subject:               pkix.Name{CommonName: "localhost"},
		NotBefore:             time.Now(),
		NotAfter:              time.Now().AddDate(5, 5, 5),
		// see http://golang.org/pkg/crypto/x509/#KeyUsage
		ExtKeyUsage: []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth, x509.ExtKeyUsageServerAuth},
		KeyUsage:    x509.KeyUsageDigitalSignature | x509.KeyUsageCertSign,
	}
)

const (
	jwtTokenPath = "/var/run/secrets/kubernetes.io/serviceaccount/token"
)

func getJWTToken() (string, error) {
	saToken := jwtTokenPath

	token, err := os.ReadFile(saToken)
	if err != nil {
		return "", err
	}

	return string(token), nil
}

func setJWTToken(md metadata.MD) {
	// test JWT
	jwtToken, err := getJWTToken()
	if err != nil {
		klog.Errorf("getJWTToken error: %v\n", err)
	} else {
		klog.Infof("getJWTToken: %s\n", jwtToken)
		md.Set("Authorization", fmt.Sprintf("Bearer %s", jwtToken))
	}
}

func generate() {
	bitSize := 4096
	privateKey, err := rsa.GenerateKey(rand.Reader, bitSize)
	if err != nil {
		panic(err)
	}

	certificate, err := x509.CreateCertificate(rand.Reader, certificateTemplate, certificateTemplate, privateKey.Public(), privateKey)

	// Encode private privateKey to PKCS#1 ASN.1 PEM.
	keyPEM := pem.EncodeToMemory(
		&pem.Block{
			Type:  "RSA PRIVATE KEY",
			Bytes: x509.MarshalPKCS1PrivateKey(privateKey),
		},
	)

	//pem encoding of certificate
	certPEM := pem.EncodeToMemory(
		&pem.Block{
			Type:  "CERTIFICATE",
			Bytes: certificate,
		},
	)

	// Write private privateKey to file.
	if err := ioutil.WriteFile(keyPath, keyPEM, 0700); err != nil {
		panic(err)
	}

	if err := ioutil.WriteFile(certPath, certPEM, 0700); err != nil {
		panic(err)
	}
}

func GetTLSConfig() (*tls.Config, error) {
	// rootCA
	//rootCertPool := x509.NewCertPool()
	//ok := rootCertPool.AppendCertsFromPEM([]byte(rootCert))
	//if !ok {
	//	return nil, fmt.Errorf("failed to create TLS dial option with root certificates")
	//}

	//if !inited {
	//	generate()
	//	inited = true
	//}
	//_, err := tls.LoadX509KeyPair(certPath, keyPath)
	//if err != nil {
	//	panic(err)
	//}
	//
	//kl, err := os.OpenFile(keyLogFileName, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
	//if err != nil {
	//	return nil, err
	//}
	//fmt.Fprintf(kl, "# SSL/TLS secrets log file, generated by go\n")

	cfg := &tls.Config{
		ServerName: "istiod.istio-system.svc",
		// used to verify the server certificate
		//RootCAs:            rootCertPool,
		InsecureSkipVerify: true,
		Certificates:       nil, //[]tls.Certificate{clientCert},
		//KeyLogWriter:       kl,
	}
	return cfg, nil
}
